<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>tensap.tensor_algebra.tensors.diagonal_tensor API documentation</title>
<meta name="description" content="Module diagonal_tensor â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tensap.tensor_algebra.tensors.diagonal_tensor</code></h1>
</header>
<section id="section-intro">
<p>Module diagonal_tensor.</p>
<p>Copyright (c) 2020, Anthony Nouy, Erwan Grelier
This file is part of tensap (tensor approximation package).</p>
<p>tensap is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>tensap is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with tensap.
If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Module diagonal_tensor.

Copyright (c) 2020, Anthony Nouy, Erwan Grelier
This file is part of tensap (tensor approximation package).

tensap is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

tensap is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with tensap.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#39;&#39;&#39;

from copy import deepcopy
import numpy as np
import tensap


class DiagonalTensor:
    &#39;&#39;&#39;
    Class DiagonalTensor.

    Attributes
    ----------
    data : numpy.ndarray
        The diagonal entries of the tensor.
    order : int
        The order of the tensor.
    shape : numpy.ndarray
        The shape of the tensor.
    is_orth : bool
        Boolean indicating if the representation of the tensor is orthogonal
        (i.e. one mu-matricization is orthogonal).

    &#39;&#39;&#39;

    def __init__(self, data, order=None):
        &#39;&#39;&#39;
        Constructor for the class DiagonalTensor.

        Parameters
        ----------
        data : numpy.ndarray or tensap.DiagonalTensor
            The diagonal entries of the tensor.
        order : int, optional
            The order of the tensor. The default is None.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.is_orth = True

        if order is None:
            assert isinstance(data, DiagonalTensor), \
                &#39;The input must be a DiagonalTensor.&#39;
            self.data = np.array(data.data)
            self.order = data.order
            self.shape = data.shape
        else:
            assert isinstance(data, (list, np.ndarray)), \
                &#39;The input must be a list or numpy.ndarray.&#39;
            self.data = np.reshape(data, -1)
            self.order = order
            self.shape = np.full(order, self.data.size)

    def __repr__(self):
        return (&#39;&lt;{} DiagonalTensor:{n}&#39; +
                &#39;{t}order = {},{n}&#39; +
                &#39;{t}shape = {},{n}&#39; +
                &#39;{t}is_orth = {}&gt;&#39;).format(&#39;x&#39;.join(map(str, self.shape)),
                                           self.order,
                                           self.shape,
                                           self.is_orth,
                                           t=&#39;\t&#39;, n=&#39;\n&#39;)

    def tree_based_tensor(self, tree=None, is_active_node=None):
        &#39;&#39;&#39;
        Convert the tensap.DiagonalTensor into a tensap.TreeBasedTensor.

        Parameters
        ----------
        tree : tensap.DimensionTree, optional
            The tree associated with the tree-based tensor representation. The
            default is a linear tree.
        is_active_node : list or numpy.ndarray, optional
            List or array of booleans indicating if each node of the tree is
            active. The default is True for all nodes except the leaves.

        Raises
        ------
        ValueError
            If the internal nodes are not all active.

        Returns
        -------
        tensap.TreeBasedTensor
            A tree-based tensor representation of the diagonal tensor.

        &#39;&#39;&#39;
        if tree is None:
            tree = tensap.DimensionTree.linear(self.order)

        if is_active_node is None:
            is_active_node = np.full(tree.nb_nodes, True)
            is_active_node[tree.is_leaf] = False

        tensors = np.empty(tree.nb_nodes, dtype=object)
        tensors[np.logical_not(is_active_node)] = tensap.FullTensor([])
        r = self.shape[0]
        for nod in np.arange(1, tree.nb_nodes+1):
            ch = tree.children(nod)
            if tree.parent(nod) == 0:
                tensors[nod-1] = tensap.FullTensor.diag(self.data, ch.size)
            elif tree.is_leaf[nod-1] and is_active_node[nod-1]:
                tensors[nod-1] = tensap.FullTensor(np.eye(r), 2, [r, r])
            elif is_active_node[nod-1]:
                tensors[nod-1] = tensap.FullTensor.diag(np.ones(r), ch.size+1)
            elif not tree.is_leaf[nod-1] and not is_active_node[nod-1]:
                raise ValueError(&#39;The internal nodes should be active.&#39;)
        return tensap.TreeBasedTensor(tensors, tree)

    @property
    def ndim(self):
        &#39;&#39;&#39;
        Compute the order of the tensor. Equivalent to self.order.

        Returns
        -------
        int
            The order of the tensor.

        &#39;&#39;&#39;
        return self.order

    def storage(self):
        &#39;&#39;&#39;
        Return the storage complexity of the DiagonalTensor.

        Returns
        -------
        int
            The storage complexity of the DiagonalTensor.

        &#39;&#39;&#39;
        return self.data.size

    def sparse_storage(self):
        &#39;&#39;&#39;
        Return the sparse storage complexity of the DiagonalTensor.

        Returns
        -------
        int
            The sparse storage complexity of the DiagonalTensor.

        &#39;&#39;&#39;
        return np.count_nonzero(self.data)

    def __add__(self, y):
        return DiagonalTensor(self.data + y.data, self.order)

    def __neg__(self):
        return DiagonalTensor(-self.data, self.order)

    def __sub__(self, y):
        return DiagonalTensor(self.data - y.data, self.order)

    def __mul__(self, y):
        return DiagonalTensor(self.data * y.data, self.order)

    def reshape(self, shape):
        &#39;&#39;&#39;
        Reshape the tensor. The method has no effet.

        Parameters
        ----------
        shape : list or numpy.ndarray
            The new shape of the tensor.

        Returns
        -------
        tensor : DiagonalTensor
            The reshaped tensor.

        &#39;&#39;&#39;
        out = deepcopy(self)
        out.shape = np.ravel(shape)
        return out

    def sub_tensor(self, *args):
        &#39;&#39;&#39;
        Extract a subtensor of the tensor.

        See also tensap.FullTensor.sub_tensor.

        Parameters
        ----------
        *indices : list
            The indices to extract in each dimension. &#39;:&#39; indicates all the
            indices.

        Returns
        -------
        FullTensor
            The subtensor.

        &#39;&#39;&#39;

        out = self.full()
        return out.sub_tensor(*args)

    def update_attributes(self):
        &#39;&#39;&#39;
        Update the attribute shape of self if data or order have been modified.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.shape = np.full(self.order, self.data.size)

    def tensor_vector_product(self, vectors):
        &#39;&#39;&#39;
        Compute the contraction of the tensor with vectors.

        Compute the contraction of self with each vector contained in the list
        vectors along all the dimensions. The operation is such that V[k] is
        contracted with the k-th dimension of self.

        Parameters
        ----------
        vectors : numpy.ndarray or list of numpy.ndarray
            The vectors to use in the product.

        Returns
        -------
        DiagonalTensor
            The tensor after the contractions with the vectors.

        &#39;&#39;&#39;
        if isinstance(vectors, list):
            vectors = np.hstack([np.reshape(x, [-1, 1]) for x in vectors])
        data = self.data * np.prod(vectors, 1)
        order = self.order - vectors.shape[1]
        if order == 0:
            return np.sum(data)
        return DiagonalTensor(data, order)

    def tensor_matrix_product(self, matrices, dims=None):
        &#39;&#39;&#39;
        Contract a tensor with matrices.

        The second dimension of the matrix matrices[k] is contracted with the
        k-th dimension of self, with the indices k given in dims (if provided).

        See also tensap.FullTensor.tensor_matrix_product.

        Parameters
        ----------
        matrices : numpy.ndarray or list of numpy.ndarray
            The matrices to use in the product.
        dims : list or numpy.ndarray, optional
            Indices of the contractions. The default is None, indicating all
            the dimensions.

        Returns
        -------
        FullTensor
            The tensor after the contractions with the matrices.

        &#39;&#39;&#39;
        out = self.full()
        return out.tensor_matrix_product(matrices, dims)

    def tensor_matrix_product_eval_diag(self, matrices, dims=None):
        &#39;&#39;&#39;
        Evaluate the diagonal of a tensor obtained by contraction with
        matrices.

        Provides the diagonal of the tensor obtained by contracting the tensor
        with matrices H[k] along dimensions dims(k)+1, for k = 0, ...,
        dims.size-1.

        Parameters
        ----------
        matrices : list
            The matrices to use in the product.
        dims : list or numpy.ndarray, optional
            Indices of the contractions. The default is None, indicating all
            the dimensions.

        Returns
        -------
        tensap.DiagonalTensor or numpy.ndarray
            The diagonal of the contractions of the tensor with the matrices.

        &#39;&#39;&#39;
        return self.tensor_matrix_product(matrices, dims).eval_diag(dims)

    def tensor_diagonal_matrix_product(self, matrices):
        &#39;&#39;&#39;
        Contract a FullTensor with matrices built from their diagonals.

        The second dimension of the matrix matrices[k] is contracted with the
        k-th dimension of self.

        Parameters
        ----------
        matrices : numpy.ndarray or list of numpy.ndarray
            The diagonals of the matrices to use in the product.

        Returns
        -------
        DiagonalTensor
            The tensor after the contractions with the matrices.

        &#39;&#39;&#39;
        if isinstance(matrices, list):
            matrices = np.hstack([np.reshape(x, [-1, 1]) for x in matrices])
        return DiagonalTensor(np.prod(matrices, 1) * self.data, self.order)

    def tensordot(self, y, dims1, dims2=None):
        &#39;&#39;&#39;
        Contract two tensors along specified dimensions.

        See also tensap.FullTensor.tensordot.

        Parameters
        ----------
        tensor2 : Tensor
            The second tensor of the contraction.
        dims1 : list or int
            The dimensions of contractions for the first tensor.
        dims2 : list or int, optional
            The dimensions of contractions for the second tensor. The default
            is None which indicates, if dims1 = 0, to perform the outer
            product of the two tensors, similarly to tensorflow.tensordot.

        Returns
        -------
        out : FullTensor
            The resulting tensor.

        &#39;&#39;&#39;
        x = self.full()
        y = y.full()
        return x.tensordot(y, dims1, dims2)

    def dot(self, y):
        &#39;&#39;&#39;
        Return the inner product of two tensors.

        Parameters
        ----------
        tensor2 : DiagonalTensor
            The second tensor of the inner products.

        Returns
        -------
        numpy.float
            The inner product of the two tensors.

        &#39;&#39;&#39;
        return np.sum(self.data*y.data)

    def norm(self):
        &#39;&#39;&#39;
        Compute the canonical norm of the DiagonalTensor.

        Returns
        -------
        numpy.float
            The norm of the tensor.

        &#39;&#39;&#39;
        return np.linalg.norm(self.data)

    def full(self):
        &#39;&#39;&#39;
        Convert the DiagonalTensor to a tensap.FullTensor.

        Returns
        -------
        tensap.FullTensor
            The DiagonalTensor as a tensap.FullTensor.

        &#39;&#39;&#39;
        return tensap.FullTensor.diag(self.data, self.order)

    def numpy(self):
        &#39;&#39;&#39;
        Convert the DiagonalTensor to a numpy.ndarray.

        Returns
        -------
        numpy.ndarray
            The DiagonalTensor as a numpy.ndarray.

        &#39;&#39;&#39;
        return self.full().data

    def sparse(self):
        &#39;&#39;&#39;
        Convert the DiagonalTensor to a tensap.SparseTensor.

        Returns
        -------
        tensap.SparseTensor
            The DiagonalTensor as a tensap.SparseTensor.

        &#39;&#39;&#39;
        ind = np.nonzero(self.data)[0]
        data = self.data[self.data != 0]
        indices = tensap.MultiIndices(np.tile(np.reshape(ind, [-1, 1]),
                                              (1, self.order)))
        return tensap.SparseTensor(data, indices, self.shape)

    def cat(self, y):
        &#39;&#39;&#39;
        Concatenate the tensors.

        Concatenates self and y in a tensor z such that:
        z(i_1 ,..., i_d) = x(i_1, ..., i_d) if i_k &lt;= sz[k]-1 for k in dims,
        z(i_1, ..., i_d) = y(i_1-sz[0], ..., i_d-sz[d-1]) if i_k &gt;= sz[k]
        for k in dims,
        z(i_1, ..., i_d) = 0 otherwise, with sz = self.shape and
        dims = range(self.order).

        Parameters
        ----------
        y : DiagonalTensor
            The second tensor to be concatenaed.
        Returns
        -------
        DiagonalTensor
            The concatenated tensors.

        &#39;&#39;&#39;
        data = np.concatenate((self.data, y.data))
        return DiagonalTensor(data, order=self.order)

    def kron(self, y):
        &#39;&#39;&#39;
        Kronecker product of tensors.

        Similar to numpy.kron but for arbitrary tensors.

        Parameters
        ----------
        tensor2 : DiagonalTensor
            The second tensor of the Kronecker product.

        Returns
        -------
        DiagonalTensor
            The tensor resulting from the Kronecker product.

        &#39;&#39;&#39;
        data = np.reshape(np.outer(y.data, self.data), -1, order=&#39;F&#39;)
        return DiagonalTensor(data, order=self.order)

    def dot_with_rank_one_metric(self, y, matrix):
        &#39;&#39;&#39;
        Compute the weighted inner product of two tensors.

        Compute the weighted canonical inner product of self and y,
        where the inner product related to dimension k is weighted by
        matrix[k]. It is equivalent to
        self.dot(y.tensor_matrix_product(matrix)), but can be much faster.

        Parameters
        ----------
        y : DiagonalTensor
            The second tensor of the inner product.
        matrix : list or numpy.ndarray or FullTensor
            The weight matrix.

        Returns
        -------
        numpy.float
            The weighted inner product.

        &#39;&#39;&#39;
        if isinstance(matrix, list):
            matrix = np.hstack([np.reshape(x, [-1, 1]) for x in matrix])
        matrix = np.reshape(np.expand_dims(matrix, 1),
                            (self.shape[0], y.shape[0], self.order), order=&#39;F&#39;)
        matrix = np.prod(matrix, 2)
        return np.matmul(np.transpose(self.data), np.matmul(matrix, y.data))

    def tensordot_matrix_product_except_dim(self, y, matrices, dim):
        &#39;&#39;&#39;
        Particular type of contraction.

        Compute a special contraction of two tensors self, y, a list of
        matrices matrices and a particular dimension dim. Note that dim must
        be a scalar, while matrices must be a list array with self.order
        elements.

        Parameters
        ----------
        y : DiagonalTensor
            The second tensor of the contraction.
        matrices : list
            The list of matrices of the contraction.
        dim : int
            The excluded dimension.

        Returns
        -------
        numpy.ndarray
            The result of the contraction.

        &#39;&#39;&#39;
        ind = np.setdiff1d(range(self.order), dim)
        matrices = np.hstack([matrices[x] for x in ind])
        matrices = np.reshape(np.expand_dims(matrices, 1),
                              (self.shape[0], y.shape[0], ind.size),
                              order=&#39;F&#39;)
        matrices = np.prod(matrices, 2)
        return matrices * np.outer(self.data, y.data)

    def orth(self):
        &#39;&#39;&#39;
        Placeholder method returning a copy of self.

        Returns
        -------
        DiagonalTensor
            A copy of self.

        &#39;&#39;&#39;
        return deepcopy(self)

    def eval_diag(self, dims=None):
        &#39;&#39;&#39;
        Extract the diagonal of the tensor.

        Parameters
        ----------
        dims : list of numpy.ndarray, optional
            The dimensions associated with the indices of the diagonal. The
            default is None,indicating that the indices refer to all the
            dimensions.

        Returns
        -------
        data : DiagonalTensor or numpy.ndarray
            The evaluations of the diagonal of the tensor.

        &#39;&#39;&#39;
        if dims is None or np.size(dims) == self.order:
            out = np.array(self.data)
        else:
            dims = np.sort(np.atleast_1d(dims))
            rep = np.concatenate((np.arange(dims[0]+1),
                                  np.arange(dims[-1]+1, self.order)))
            out = deepcopy(self)
            out.shape = out.shape[rep]
            out.order = np.size(rep)
        return out

    def eval_at_indices(self, ind, dims=None):
        &#39;&#39;&#39;
        Evaluate the tensor at indices.

        If dims is None, return
        s(k) = x(indices(k, 1), indices(k, 2), ..., indices(k, d)),
        1 &lt;= k &lt;= self.shape[0].

        If dims is not None, return a partial evaluation: up to a permutation
        (placing the dimensions dims on the left), return
        s(k, i_1, ..., i_d&#39;) = x(indices(k, 1), indices(k, 2), ...,
        indices(k, M), i_1, ..., i_d&#39;),
        1 &lt;= k &lt;= self.shape[0], with M = dims.size and d&#39; = self.order - M.

        Parameters
        ----------
        indices : list of numpy.ndarray
            The indices of the tensor.
        dims : list of numpy.ndarray, optional
            The dimensions associated with the indices. The default is None,
            indicating that indices refers to all the dimensions.

        Returns
        -------
        evaluations : numpy.ndarray or DiagonalTensor
            The evaluations of the tensor.

        &#39;&#39;&#39;

        ind = np.atleast_2d(ind)
        r = np.full(ind.shape[0], True)
        for k in range(ind.shape[1]):
            r = np.logical_and(r, ind[:, 0] == ind[:, k])

        if dims is None or np.size(dims) == self.order:
            out = np.zeros(ind.shape[0])
            out[r] = self.data[ind[r, 0]]
            return out
        raise NotImplementedError(&#39;Method not implemented.&#39;)

    def transpose(self, dims):
        &#39;&#39;&#39;
        Transpose (permute) the dimensions of the tensor.

        Parameters
        ----------
        dims : list or numpy.ndarray
            The new ordering of the dimensions.

        Returns
        -------
        tensor : DiagonalTensor
            The transposed (permuted) tensor.

        &#39;&#39;&#39;
        out = deepcopy(self)
        out.shape = out.shape[dims]
        return out

    def itranspose(self, dims):
        &#39;&#39;&#39;
        Return the inverse transpose (permutation) of the dimensions of the
        tensor.

        Parameters
        ----------
        dims : list or numpy.ndarray
            The original transpose (permutation) indices.

        Returns
        -------
        DiagonalTensor
            The transposed (permuted) tensor.

        &#39;&#39;&#39;
        return self.transpose(np.argsort(dims))

    @staticmethod
    def create(generator, rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order using a given
        generator.

        Parameters
        ----------
        generator : function
            Function generating an array, given a rank.
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor(generator(rank), order)

    @staticmethod
    def rand(rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order with i.i.d.
        entries drawn according to the uniform distribution on [0, 1].

        Parameters
        ----------
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor.create(np.random.rand, rank, order)

    @staticmethod
    def randn(rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order with i.i.d.
        entries drawn according to the standard gaussian distribution.

        Parameters
        ----------
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor.create(np.random.randn, rank, order)

    @staticmethod
    def zeros(rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order with with entries
        equal to 0.

        Parameters
        ----------
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor.create(np.zeros, rank, order)

    @staticmethod
    def ones(rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order with with
        entries equal to 1.

        Parameters
        ----------
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor.create(np.ones, rank, order)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor"><code class="flex name class">
<span>class <span class="ident">DiagonalTensor</span></span>
<span>(</span><span>data, order=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class DiagonalTensor.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The diagonal entries of the tensor.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the tensor.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The shape of the tensor.</dd>
<dt><strong><code>is_orth</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean indicating if the representation of the tensor is orthogonal
(i.e. one mu-matricization is orthogonal).</dd>
</dl>
<p>Constructor for the class DiagonalTensor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code> or <code>tensap.DiagonalTensor</code></dt>
<dd>The diagonal entries of the tensor.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The order of the tensor. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiagonalTensor:
    &#39;&#39;&#39;
    Class DiagonalTensor.

    Attributes
    ----------
    data : numpy.ndarray
        The diagonal entries of the tensor.
    order : int
        The order of the tensor.
    shape : numpy.ndarray
        The shape of the tensor.
    is_orth : bool
        Boolean indicating if the representation of the tensor is orthogonal
        (i.e. one mu-matricization is orthogonal).

    &#39;&#39;&#39;

    def __init__(self, data, order=None):
        &#39;&#39;&#39;
        Constructor for the class DiagonalTensor.

        Parameters
        ----------
        data : numpy.ndarray or tensap.DiagonalTensor
            The diagonal entries of the tensor.
        order : int, optional
            The order of the tensor. The default is None.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.is_orth = True

        if order is None:
            assert isinstance(data, DiagonalTensor), \
                &#39;The input must be a DiagonalTensor.&#39;
            self.data = np.array(data.data)
            self.order = data.order
            self.shape = data.shape
        else:
            assert isinstance(data, (list, np.ndarray)), \
                &#39;The input must be a list or numpy.ndarray.&#39;
            self.data = np.reshape(data, -1)
            self.order = order
            self.shape = np.full(order, self.data.size)

    def __repr__(self):
        return (&#39;&lt;{} DiagonalTensor:{n}&#39; +
                &#39;{t}order = {},{n}&#39; +
                &#39;{t}shape = {},{n}&#39; +
                &#39;{t}is_orth = {}&gt;&#39;).format(&#39;x&#39;.join(map(str, self.shape)),
                                           self.order,
                                           self.shape,
                                           self.is_orth,
                                           t=&#39;\t&#39;, n=&#39;\n&#39;)

    def tree_based_tensor(self, tree=None, is_active_node=None):
        &#39;&#39;&#39;
        Convert the tensap.DiagonalTensor into a tensap.TreeBasedTensor.

        Parameters
        ----------
        tree : tensap.DimensionTree, optional
            The tree associated with the tree-based tensor representation. The
            default is a linear tree.
        is_active_node : list or numpy.ndarray, optional
            List or array of booleans indicating if each node of the tree is
            active. The default is True for all nodes except the leaves.

        Raises
        ------
        ValueError
            If the internal nodes are not all active.

        Returns
        -------
        tensap.TreeBasedTensor
            A tree-based tensor representation of the diagonal tensor.

        &#39;&#39;&#39;
        if tree is None:
            tree = tensap.DimensionTree.linear(self.order)

        if is_active_node is None:
            is_active_node = np.full(tree.nb_nodes, True)
            is_active_node[tree.is_leaf] = False

        tensors = np.empty(tree.nb_nodes, dtype=object)
        tensors[np.logical_not(is_active_node)] = tensap.FullTensor([])
        r = self.shape[0]
        for nod in np.arange(1, tree.nb_nodes+1):
            ch = tree.children(nod)
            if tree.parent(nod) == 0:
                tensors[nod-1] = tensap.FullTensor.diag(self.data, ch.size)
            elif tree.is_leaf[nod-1] and is_active_node[nod-1]:
                tensors[nod-1] = tensap.FullTensor(np.eye(r), 2, [r, r])
            elif is_active_node[nod-1]:
                tensors[nod-1] = tensap.FullTensor.diag(np.ones(r), ch.size+1)
            elif not tree.is_leaf[nod-1] and not is_active_node[nod-1]:
                raise ValueError(&#39;The internal nodes should be active.&#39;)
        return tensap.TreeBasedTensor(tensors, tree)

    @property
    def ndim(self):
        &#39;&#39;&#39;
        Compute the order of the tensor. Equivalent to self.order.

        Returns
        -------
        int
            The order of the tensor.

        &#39;&#39;&#39;
        return self.order

    def storage(self):
        &#39;&#39;&#39;
        Return the storage complexity of the DiagonalTensor.

        Returns
        -------
        int
            The storage complexity of the DiagonalTensor.

        &#39;&#39;&#39;
        return self.data.size

    def sparse_storage(self):
        &#39;&#39;&#39;
        Return the sparse storage complexity of the DiagonalTensor.

        Returns
        -------
        int
            The sparse storage complexity of the DiagonalTensor.

        &#39;&#39;&#39;
        return np.count_nonzero(self.data)

    def __add__(self, y):
        return DiagonalTensor(self.data + y.data, self.order)

    def __neg__(self):
        return DiagonalTensor(-self.data, self.order)

    def __sub__(self, y):
        return DiagonalTensor(self.data - y.data, self.order)

    def __mul__(self, y):
        return DiagonalTensor(self.data * y.data, self.order)

    def reshape(self, shape):
        &#39;&#39;&#39;
        Reshape the tensor. The method has no effet.

        Parameters
        ----------
        shape : list or numpy.ndarray
            The new shape of the tensor.

        Returns
        -------
        tensor : DiagonalTensor
            The reshaped tensor.

        &#39;&#39;&#39;
        out = deepcopy(self)
        out.shape = np.ravel(shape)
        return out

    def sub_tensor(self, *args):
        &#39;&#39;&#39;
        Extract a subtensor of the tensor.

        See also tensap.FullTensor.sub_tensor.

        Parameters
        ----------
        *indices : list
            The indices to extract in each dimension. &#39;:&#39; indicates all the
            indices.

        Returns
        -------
        FullTensor
            The subtensor.

        &#39;&#39;&#39;

        out = self.full()
        return out.sub_tensor(*args)

    def update_attributes(self):
        &#39;&#39;&#39;
        Update the attribute shape of self if data or order have been modified.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.shape = np.full(self.order, self.data.size)

    def tensor_vector_product(self, vectors):
        &#39;&#39;&#39;
        Compute the contraction of the tensor with vectors.

        Compute the contraction of self with each vector contained in the list
        vectors along all the dimensions. The operation is such that V[k] is
        contracted with the k-th dimension of self.

        Parameters
        ----------
        vectors : numpy.ndarray or list of numpy.ndarray
            The vectors to use in the product.

        Returns
        -------
        DiagonalTensor
            The tensor after the contractions with the vectors.

        &#39;&#39;&#39;
        if isinstance(vectors, list):
            vectors = np.hstack([np.reshape(x, [-1, 1]) for x in vectors])
        data = self.data * np.prod(vectors, 1)
        order = self.order - vectors.shape[1]
        if order == 0:
            return np.sum(data)
        return DiagonalTensor(data, order)

    def tensor_matrix_product(self, matrices, dims=None):
        &#39;&#39;&#39;
        Contract a tensor with matrices.

        The second dimension of the matrix matrices[k] is contracted with the
        k-th dimension of self, with the indices k given in dims (if provided).

        See also tensap.FullTensor.tensor_matrix_product.

        Parameters
        ----------
        matrices : numpy.ndarray or list of numpy.ndarray
            The matrices to use in the product.
        dims : list or numpy.ndarray, optional
            Indices of the contractions. The default is None, indicating all
            the dimensions.

        Returns
        -------
        FullTensor
            The tensor after the contractions with the matrices.

        &#39;&#39;&#39;
        out = self.full()
        return out.tensor_matrix_product(matrices, dims)

    def tensor_matrix_product_eval_diag(self, matrices, dims=None):
        &#39;&#39;&#39;
        Evaluate the diagonal of a tensor obtained by contraction with
        matrices.

        Provides the diagonal of the tensor obtained by contracting the tensor
        with matrices H[k] along dimensions dims(k)+1, for k = 0, ...,
        dims.size-1.

        Parameters
        ----------
        matrices : list
            The matrices to use in the product.
        dims : list or numpy.ndarray, optional
            Indices of the contractions. The default is None, indicating all
            the dimensions.

        Returns
        -------
        tensap.DiagonalTensor or numpy.ndarray
            The diagonal of the contractions of the tensor with the matrices.

        &#39;&#39;&#39;
        return self.tensor_matrix_product(matrices, dims).eval_diag(dims)

    def tensor_diagonal_matrix_product(self, matrices):
        &#39;&#39;&#39;
        Contract a FullTensor with matrices built from their diagonals.

        The second dimension of the matrix matrices[k] is contracted with the
        k-th dimension of self.

        Parameters
        ----------
        matrices : numpy.ndarray or list of numpy.ndarray
            The diagonals of the matrices to use in the product.

        Returns
        -------
        DiagonalTensor
            The tensor after the contractions with the matrices.

        &#39;&#39;&#39;
        if isinstance(matrices, list):
            matrices = np.hstack([np.reshape(x, [-1, 1]) for x in matrices])
        return DiagonalTensor(np.prod(matrices, 1) * self.data, self.order)

    def tensordot(self, y, dims1, dims2=None):
        &#39;&#39;&#39;
        Contract two tensors along specified dimensions.

        See also tensap.FullTensor.tensordot.

        Parameters
        ----------
        tensor2 : Tensor
            The second tensor of the contraction.
        dims1 : list or int
            The dimensions of contractions for the first tensor.
        dims2 : list or int, optional
            The dimensions of contractions for the second tensor. The default
            is None which indicates, if dims1 = 0, to perform the outer
            product of the two tensors, similarly to tensorflow.tensordot.

        Returns
        -------
        out : FullTensor
            The resulting tensor.

        &#39;&#39;&#39;
        x = self.full()
        y = y.full()
        return x.tensordot(y, dims1, dims2)

    def dot(self, y):
        &#39;&#39;&#39;
        Return the inner product of two tensors.

        Parameters
        ----------
        tensor2 : DiagonalTensor
            The second tensor of the inner products.

        Returns
        -------
        numpy.float
            The inner product of the two tensors.

        &#39;&#39;&#39;
        return np.sum(self.data*y.data)

    def norm(self):
        &#39;&#39;&#39;
        Compute the canonical norm of the DiagonalTensor.

        Returns
        -------
        numpy.float
            The norm of the tensor.

        &#39;&#39;&#39;
        return np.linalg.norm(self.data)

    def full(self):
        &#39;&#39;&#39;
        Convert the DiagonalTensor to a tensap.FullTensor.

        Returns
        -------
        tensap.FullTensor
            The DiagonalTensor as a tensap.FullTensor.

        &#39;&#39;&#39;
        return tensap.FullTensor.diag(self.data, self.order)

    def numpy(self):
        &#39;&#39;&#39;
        Convert the DiagonalTensor to a numpy.ndarray.

        Returns
        -------
        numpy.ndarray
            The DiagonalTensor as a numpy.ndarray.

        &#39;&#39;&#39;
        return self.full().data

    def sparse(self):
        &#39;&#39;&#39;
        Convert the DiagonalTensor to a tensap.SparseTensor.

        Returns
        -------
        tensap.SparseTensor
            The DiagonalTensor as a tensap.SparseTensor.

        &#39;&#39;&#39;
        ind = np.nonzero(self.data)[0]
        data = self.data[self.data != 0]
        indices = tensap.MultiIndices(np.tile(np.reshape(ind, [-1, 1]),
                                              (1, self.order)))
        return tensap.SparseTensor(data, indices, self.shape)

    def cat(self, y):
        &#39;&#39;&#39;
        Concatenate the tensors.

        Concatenates self and y in a tensor z such that:
        z(i_1 ,..., i_d) = x(i_1, ..., i_d) if i_k &lt;= sz[k]-1 for k in dims,
        z(i_1, ..., i_d) = y(i_1-sz[0], ..., i_d-sz[d-1]) if i_k &gt;= sz[k]
        for k in dims,
        z(i_1, ..., i_d) = 0 otherwise, with sz = self.shape and
        dims = range(self.order).

        Parameters
        ----------
        y : DiagonalTensor
            The second tensor to be concatenaed.
        Returns
        -------
        DiagonalTensor
            The concatenated tensors.

        &#39;&#39;&#39;
        data = np.concatenate((self.data, y.data))
        return DiagonalTensor(data, order=self.order)

    def kron(self, y):
        &#39;&#39;&#39;
        Kronecker product of tensors.

        Similar to numpy.kron but for arbitrary tensors.

        Parameters
        ----------
        tensor2 : DiagonalTensor
            The second tensor of the Kronecker product.

        Returns
        -------
        DiagonalTensor
            The tensor resulting from the Kronecker product.

        &#39;&#39;&#39;
        data = np.reshape(np.outer(y.data, self.data), -1, order=&#39;F&#39;)
        return DiagonalTensor(data, order=self.order)

    def dot_with_rank_one_metric(self, y, matrix):
        &#39;&#39;&#39;
        Compute the weighted inner product of two tensors.

        Compute the weighted canonical inner product of self and y,
        where the inner product related to dimension k is weighted by
        matrix[k]. It is equivalent to
        self.dot(y.tensor_matrix_product(matrix)), but can be much faster.

        Parameters
        ----------
        y : DiagonalTensor
            The second tensor of the inner product.
        matrix : list or numpy.ndarray or FullTensor
            The weight matrix.

        Returns
        -------
        numpy.float
            The weighted inner product.

        &#39;&#39;&#39;
        if isinstance(matrix, list):
            matrix = np.hstack([np.reshape(x, [-1, 1]) for x in matrix])
        matrix = np.reshape(np.expand_dims(matrix, 1),
                            (self.shape[0], y.shape[0], self.order), order=&#39;F&#39;)
        matrix = np.prod(matrix, 2)
        return np.matmul(np.transpose(self.data), np.matmul(matrix, y.data))

    def tensordot_matrix_product_except_dim(self, y, matrices, dim):
        &#39;&#39;&#39;
        Particular type of contraction.

        Compute a special contraction of two tensors self, y, a list of
        matrices matrices and a particular dimension dim. Note that dim must
        be a scalar, while matrices must be a list array with self.order
        elements.

        Parameters
        ----------
        y : DiagonalTensor
            The second tensor of the contraction.
        matrices : list
            The list of matrices of the contraction.
        dim : int
            The excluded dimension.

        Returns
        -------
        numpy.ndarray
            The result of the contraction.

        &#39;&#39;&#39;
        ind = np.setdiff1d(range(self.order), dim)
        matrices = np.hstack([matrices[x] for x in ind])
        matrices = np.reshape(np.expand_dims(matrices, 1),
                              (self.shape[0], y.shape[0], ind.size),
                              order=&#39;F&#39;)
        matrices = np.prod(matrices, 2)
        return matrices * np.outer(self.data, y.data)

    def orth(self):
        &#39;&#39;&#39;
        Placeholder method returning a copy of self.

        Returns
        -------
        DiagonalTensor
            A copy of self.

        &#39;&#39;&#39;
        return deepcopy(self)

    def eval_diag(self, dims=None):
        &#39;&#39;&#39;
        Extract the diagonal of the tensor.

        Parameters
        ----------
        dims : list of numpy.ndarray, optional
            The dimensions associated with the indices of the diagonal. The
            default is None,indicating that the indices refer to all the
            dimensions.

        Returns
        -------
        data : DiagonalTensor or numpy.ndarray
            The evaluations of the diagonal of the tensor.

        &#39;&#39;&#39;
        if dims is None or np.size(dims) == self.order:
            out = np.array(self.data)
        else:
            dims = np.sort(np.atleast_1d(dims))
            rep = np.concatenate((np.arange(dims[0]+1),
                                  np.arange(dims[-1]+1, self.order)))
            out = deepcopy(self)
            out.shape = out.shape[rep]
            out.order = np.size(rep)
        return out

    def eval_at_indices(self, ind, dims=None):
        &#39;&#39;&#39;
        Evaluate the tensor at indices.

        If dims is None, return
        s(k) = x(indices(k, 1), indices(k, 2), ..., indices(k, d)),
        1 &lt;= k &lt;= self.shape[0].

        If dims is not None, return a partial evaluation: up to a permutation
        (placing the dimensions dims on the left), return
        s(k, i_1, ..., i_d&#39;) = x(indices(k, 1), indices(k, 2), ...,
        indices(k, M), i_1, ..., i_d&#39;),
        1 &lt;= k &lt;= self.shape[0], with M = dims.size and d&#39; = self.order - M.

        Parameters
        ----------
        indices : list of numpy.ndarray
            The indices of the tensor.
        dims : list of numpy.ndarray, optional
            The dimensions associated with the indices. The default is None,
            indicating that indices refers to all the dimensions.

        Returns
        -------
        evaluations : numpy.ndarray or DiagonalTensor
            The evaluations of the tensor.

        &#39;&#39;&#39;

        ind = np.atleast_2d(ind)
        r = np.full(ind.shape[0], True)
        for k in range(ind.shape[1]):
            r = np.logical_and(r, ind[:, 0] == ind[:, k])

        if dims is None or np.size(dims) == self.order:
            out = np.zeros(ind.shape[0])
            out[r] = self.data[ind[r, 0]]
            return out
        raise NotImplementedError(&#39;Method not implemented.&#39;)

    def transpose(self, dims):
        &#39;&#39;&#39;
        Transpose (permute) the dimensions of the tensor.

        Parameters
        ----------
        dims : list or numpy.ndarray
            The new ordering of the dimensions.

        Returns
        -------
        tensor : DiagonalTensor
            The transposed (permuted) tensor.

        &#39;&#39;&#39;
        out = deepcopy(self)
        out.shape = out.shape[dims]
        return out

    def itranspose(self, dims):
        &#39;&#39;&#39;
        Return the inverse transpose (permutation) of the dimensions of the
        tensor.

        Parameters
        ----------
        dims : list or numpy.ndarray
            The original transpose (permutation) indices.

        Returns
        -------
        DiagonalTensor
            The transposed (permuted) tensor.

        &#39;&#39;&#39;
        return self.transpose(np.argsort(dims))

    @staticmethod
    def create(generator, rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order using a given
        generator.

        Parameters
        ----------
        generator : function
            Function generating an array, given a rank.
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor(generator(rank), order)

    @staticmethod
    def rand(rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order with i.i.d.
        entries drawn according to the uniform distribution on [0, 1].

        Parameters
        ----------
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor.create(np.random.rand, rank, order)

    @staticmethod
    def randn(rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order with i.i.d.
        entries drawn according to the standard gaussian distribution.

        Parameters
        ----------
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor.create(np.random.randn, rank, order)

    @staticmethod
    def zeros(rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order with with entries
        equal to 0.

        Parameters
        ----------
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor.create(np.zeros, rank, order)

    @staticmethod
    def ones(rank, order):
        &#39;&#39;&#39;
        Create a DiagonalTensor of rank rank and order order with with
        entries equal to 1.

        Parameters
        ----------
        rank : int
            The rank of the tensor.
        order : int
            The order of the tensor.

        Returns
        -------
        DiagonalTensor
            The created tensor.

        &#39;&#39;&#39;
        return DiagonalTensor.create(np.ones, rank, order)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>generator, rank, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a DiagonalTensor of rank rank and order order using a given
generator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>generator</code></strong> :&ensp;<code>function</code></dt>
<dd>Function generating an array, given a rank.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>int</code></dt>
<dd>The rank of the tensor.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The created tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create(generator, rank, order):
    &#39;&#39;&#39;
    Create a DiagonalTensor of rank rank and order order using a given
    generator.

    Parameters
    ----------
    generator : function
        Function generating an array, given a rank.
    rank : int
        The rank of the tensor.
    order : int
        The order of the tensor.

    Returns
    -------
    DiagonalTensor
        The created tensor.

    &#39;&#39;&#39;
    return DiagonalTensor(generator(rank), order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ones"><code class="name flex">
<span>def <span class="ident">ones</span></span>(<span>rank, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a DiagonalTensor of rank rank and order order with with
entries equal to 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rank</code></strong> :&ensp;<code>int</code></dt>
<dd>The rank of the tensor.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The created tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ones(rank, order):
    &#39;&#39;&#39;
    Create a DiagonalTensor of rank rank and order order with with
    entries equal to 1.

    Parameters
    ----------
    rank : int
        The rank of the tensor.
    order : int
        The order of the tensor.

    Returns
    -------
    DiagonalTensor
        The created tensor.

    &#39;&#39;&#39;
    return DiagonalTensor.create(np.ones, rank, order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.rand"><code class="name flex">
<span>def <span class="ident">rand</span></span>(<span>rank, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a DiagonalTensor of rank rank and order order with i.i.d.
entries drawn according to the uniform distribution on [0, 1].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rank</code></strong> :&ensp;<code>int</code></dt>
<dd>The rank of the tensor.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The created tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def rand(rank, order):
    &#39;&#39;&#39;
    Create a DiagonalTensor of rank rank and order order with i.i.d.
    entries drawn according to the uniform distribution on [0, 1].

    Parameters
    ----------
    rank : int
        The rank of the tensor.
    order : int
        The order of the tensor.

    Returns
    -------
    DiagonalTensor
        The created tensor.

    &#39;&#39;&#39;
    return DiagonalTensor.create(np.random.rand, rank, order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.randn"><code class="name flex">
<span>def <span class="ident">randn</span></span>(<span>rank, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a DiagonalTensor of rank rank and order order with i.i.d.
entries drawn according to the standard gaussian distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rank</code></strong> :&ensp;<code>int</code></dt>
<dd>The rank of the tensor.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The created tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def randn(rank, order):
    &#39;&#39;&#39;
    Create a DiagonalTensor of rank rank and order order with i.i.d.
    entries drawn according to the standard gaussian distribution.

    Parameters
    ----------
    rank : int
        The rank of the tensor.
    order : int
        The order of the tensor.

    Returns
    -------
    DiagonalTensor
        The created tensor.

    &#39;&#39;&#39;
    return DiagonalTensor.create(np.random.randn, rank, order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.zeros"><code class="name flex">
<span>def <span class="ident">zeros</span></span>(<span>rank, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a DiagonalTensor of rank rank and order order with with entries
equal to 0.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rank</code></strong> :&ensp;<code>int</code></dt>
<dd>The rank of the tensor.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The created tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def zeros(rank, order):
    &#39;&#39;&#39;
    Create a DiagonalTensor of rank rank and order order with with entries
    equal to 0.

    Parameters
    ----------
    rank : int
        The rank of the tensor.
    order : int
        The order of the tensor.

    Returns
    -------
    DiagonalTensor
        The created tensor.

    &#39;&#39;&#39;
    return DiagonalTensor.create(np.zeros, rank, order)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ndim"><code class="name">var <span class="ident">ndim</span></code></dt>
<dd>
<div class="desc"><p>Compute the order of the tensor. Equivalent to self.order.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The order of the tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ndim(self):
    &#39;&#39;&#39;
    Compute the order of the tensor. Equivalent to self.order.

    Returns
    -------
    int
        The order of the tensor.

    &#39;&#39;&#39;
    return self.order</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.cat"><code class="name flex">
<span>def <span class="ident">cat</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenate the tensors.</p>
<p>Concatenates self and y in a tensor z such that:
z(i_1 ,&hellip;, i_d) = x(i_1, &hellip;, i_d) if i_k &lt;= sz[k]-1 for k in dims,
z(i_1, &hellip;, i_d) = y(i_1-sz[0], &hellip;, i_d-sz[d-1]) if i_k &gt;= sz[k]
for k in dims,
z(i_1, &hellip;, i_d) = 0 otherwise, with sz = self.shape and
dims = range(self.order).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The second tensor to be concatenaed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The concatenated tensors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cat(self, y):
    &#39;&#39;&#39;
    Concatenate the tensors.

    Concatenates self and y in a tensor z such that:
    z(i_1 ,..., i_d) = x(i_1, ..., i_d) if i_k &lt;= sz[k]-1 for k in dims,
    z(i_1, ..., i_d) = y(i_1-sz[0], ..., i_d-sz[d-1]) if i_k &gt;= sz[k]
    for k in dims,
    z(i_1, ..., i_d) = 0 otherwise, with sz = self.shape and
    dims = range(self.order).

    Parameters
    ----------
    y : DiagonalTensor
        The second tensor to be concatenaed.
    Returns
    -------
    DiagonalTensor
        The concatenated tensors.

    &#39;&#39;&#39;
    data = np.concatenate((self.data, y.data))
    return DiagonalTensor(data, order=self.order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot"><code class="name flex">
<span>def <span class="ident">dot</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the inner product of two tensors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tensor2</code></strong> :&ensp;<code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The second tensor of the inner products.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.float</code></dt>
<dd>The inner product of the two tensors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dot(self, y):
    &#39;&#39;&#39;
    Return the inner product of two tensors.

    Parameters
    ----------
    tensor2 : DiagonalTensor
        The second tensor of the inner products.

    Returns
    -------
    numpy.float
        The inner product of the two tensors.

    &#39;&#39;&#39;
    return np.sum(self.data*y.data)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot_with_rank_one_metric"><code class="name flex">
<span>def <span class="ident">dot_with_rank_one_metric</span></span>(<span>self, y, matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the weighted inner product of two tensors.</p>
<p>Compute the weighted canonical inner product of self and y,
where the inner product related to dimension k is weighted by
matrix[k]. It is equivalent to
self.dot(y.tensor_matrix_product(matrix)), but can be much faster.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The second tensor of the inner product.</dd>
<dt><strong><code>matrix</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code> or <code>FullTensor</code></dt>
<dd>The weight matrix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.float</code></dt>
<dd>The weighted inner product.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dot_with_rank_one_metric(self, y, matrix):
    &#39;&#39;&#39;
    Compute the weighted inner product of two tensors.

    Compute the weighted canonical inner product of self and y,
    where the inner product related to dimension k is weighted by
    matrix[k]. It is equivalent to
    self.dot(y.tensor_matrix_product(matrix)), but can be much faster.

    Parameters
    ----------
    y : DiagonalTensor
        The second tensor of the inner product.
    matrix : list or numpy.ndarray or FullTensor
        The weight matrix.

    Returns
    -------
    numpy.float
        The weighted inner product.

    &#39;&#39;&#39;
    if isinstance(matrix, list):
        matrix = np.hstack([np.reshape(x, [-1, 1]) for x in matrix])
    matrix = np.reshape(np.expand_dims(matrix, 1),
                        (self.shape[0], y.shape[0], self.order), order=&#39;F&#39;)
    matrix = np.prod(matrix, 2)
    return np.matmul(np.transpose(self.data), np.matmul(matrix, y.data))</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_at_indices"><code class="name flex">
<span>def <span class="ident">eval_at_indices</span></span>(<span>self, ind, dims=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the tensor at indices.</p>
<p>If dims is None, return
s(k) = x(indices(k, 1), indices(k, 2), &hellip;, indices(k, d)),
1 &lt;= k &lt;= self.shape[0].</p>
<p>If dims is not None, return a partial evaluation: up to a permutation
(placing the dimensions dims on the left), return
s(k, i_1, &hellip;, i_d') = x(indices(k, 1), indices(k, 2), &hellip;,
indices(k, M), i_1, &hellip;, i_d'),
1 &lt;= k &lt;= self.shape[0], with M = dims.size and d' = self.order - M.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>list</code> of <code>numpy.ndarray</code></dt>
<dd>The indices of the tensor.</dd>
<dt><strong><code>dims</code></strong> :&ensp;<code>list</code> of <code>numpy.ndarray</code>, optional</dt>
<dd>The dimensions associated with the indices. The default is None,
indicating that indices refers to all the dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>evaluations</code></strong> :&ensp;<code>numpy.ndarray</code> or <code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The evaluations of the tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_at_indices(self, ind, dims=None):
    &#39;&#39;&#39;
    Evaluate the tensor at indices.

    If dims is None, return
    s(k) = x(indices(k, 1), indices(k, 2), ..., indices(k, d)),
    1 &lt;= k &lt;= self.shape[0].

    If dims is not None, return a partial evaluation: up to a permutation
    (placing the dimensions dims on the left), return
    s(k, i_1, ..., i_d&#39;) = x(indices(k, 1), indices(k, 2), ...,
    indices(k, M), i_1, ..., i_d&#39;),
    1 &lt;= k &lt;= self.shape[0], with M = dims.size and d&#39; = self.order - M.

    Parameters
    ----------
    indices : list of numpy.ndarray
        The indices of the tensor.
    dims : list of numpy.ndarray, optional
        The dimensions associated with the indices. The default is None,
        indicating that indices refers to all the dimensions.

    Returns
    -------
    evaluations : numpy.ndarray or DiagonalTensor
        The evaluations of the tensor.

    &#39;&#39;&#39;

    ind = np.atleast_2d(ind)
    r = np.full(ind.shape[0], True)
    for k in range(ind.shape[1]):
        r = np.logical_and(r, ind[:, 0] == ind[:, k])

    if dims is None or np.size(dims) == self.order:
        out = np.zeros(ind.shape[0])
        out[r] = self.data[ind[r, 0]]
        return out
    raise NotImplementedError(&#39;Method not implemented.&#39;)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_diag"><code class="name flex">
<span>def <span class="ident">eval_diag</span></span>(<span>self, dims=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the diagonal of the tensor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dims</code></strong> :&ensp;<code>list</code> of <code>numpy.ndarray</code>, optional</dt>
<dd>The dimensions associated with the indices of the diagonal. The
default is None,indicating that the indices refer to all the
dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code> or <code>numpy.ndarray</code></dt>
<dd>The evaluations of the diagonal of the tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_diag(self, dims=None):
    &#39;&#39;&#39;
    Extract the diagonal of the tensor.

    Parameters
    ----------
    dims : list of numpy.ndarray, optional
        The dimensions associated with the indices of the diagonal. The
        default is None,indicating that the indices refer to all the
        dimensions.

    Returns
    -------
    data : DiagonalTensor or numpy.ndarray
        The evaluations of the diagonal of the tensor.

    &#39;&#39;&#39;
    if dims is None or np.size(dims) == self.order:
        out = np.array(self.data)
    else:
        dims = np.sort(np.atleast_1d(dims))
        rep = np.concatenate((np.arange(dims[0]+1),
                              np.arange(dims[-1]+1, self.order)))
        out = deepcopy(self)
        out.shape = out.shape[rep]
        out.order = np.size(rep)
    return out</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.full"><code class="name flex">
<span>def <span class="ident">full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the DiagonalTensor to a tensap.FullTensor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensap.FullTensor</code></dt>
<dd>The DiagonalTensor as a tensap.FullTensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full(self):
    &#39;&#39;&#39;
    Convert the DiagonalTensor to a tensap.FullTensor.

    Returns
    -------
    tensap.FullTensor
        The DiagonalTensor as a tensap.FullTensor.

    &#39;&#39;&#39;
    return tensap.FullTensor.diag(self.data, self.order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.itranspose"><code class="name flex">
<span>def <span class="ident">itranspose</span></span>(<span>self, dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the inverse transpose (permutation) of the dimensions of the
tensor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dims</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>The original transpose (permutation) indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The transposed (permuted) tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def itranspose(self, dims):
    &#39;&#39;&#39;
    Return the inverse transpose (permutation) of the dimensions of the
    tensor.

    Parameters
    ----------
    dims : list or numpy.ndarray
        The original transpose (permutation) indices.

    Returns
    -------
    DiagonalTensor
        The transposed (permuted) tensor.

    &#39;&#39;&#39;
    return self.transpose(np.argsort(dims))</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.kron"><code class="name flex">
<span>def <span class="ident">kron</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Kronecker product of tensors.</p>
<p>Similar to numpy.kron but for arbitrary tensors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tensor2</code></strong> :&ensp;<code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The second tensor of the Kronecker product.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The tensor resulting from the Kronecker product.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kron(self, y):
    &#39;&#39;&#39;
    Kronecker product of tensors.

    Similar to numpy.kron but for arbitrary tensors.

    Parameters
    ----------
    tensor2 : DiagonalTensor
        The second tensor of the Kronecker product.

    Returns
    -------
    DiagonalTensor
        The tensor resulting from the Kronecker product.

    &#39;&#39;&#39;
    data = np.reshape(np.outer(y.data, self.data), -1, order=&#39;F&#39;)
    return DiagonalTensor(data, order=self.order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.norm"><code class="name flex">
<span>def <span class="ident">norm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the canonical norm of the DiagonalTensor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.float</code></dt>
<dd>The norm of the tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norm(self):
    &#39;&#39;&#39;
    Compute the canonical norm of the DiagonalTensor.

    Returns
    -------
    numpy.float
        The norm of the tensor.

    &#39;&#39;&#39;
    return np.linalg.norm(self.data)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.numpy"><code class="name flex">
<span>def <span class="ident">numpy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the DiagonalTensor to a numpy.ndarray.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>The DiagonalTensor as a numpy.ndarray.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpy(self):
    &#39;&#39;&#39;
    Convert the DiagonalTensor to a numpy.ndarray.

    Returns
    -------
    numpy.ndarray
        The DiagonalTensor as a numpy.ndarray.

    &#39;&#39;&#39;
    return self.full().data</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.orth"><code class="name flex">
<span>def <span class="ident">orth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Placeholder method returning a copy of self.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>A copy of self.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orth(self):
    &#39;&#39;&#39;
    Placeholder method returning a copy of self.

    Returns
    -------
    DiagonalTensor
        A copy of self.

    &#39;&#39;&#39;
    return deepcopy(self)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.reshape"><code class="name flex">
<span>def <span class="ident">reshape</span></span>(<span>self, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape the tensor. The method has no effet.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>The new shape of the tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tensor</code></strong> :&ensp;<code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The reshaped tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reshape(self, shape):
    &#39;&#39;&#39;
    Reshape the tensor. The method has no effet.

    Parameters
    ----------
    shape : list or numpy.ndarray
        The new shape of the tensor.

    Returns
    -------
    tensor : DiagonalTensor
        The reshaped tensor.

    &#39;&#39;&#39;
    out = deepcopy(self)
    out.shape = np.ravel(shape)
    return out</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse"><code class="name flex">
<span>def <span class="ident">sparse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the DiagonalTensor to a tensap.SparseTensor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensap.SparseTensor</code></dt>
<dd>The DiagonalTensor as a tensap.SparseTensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sparse(self):
    &#39;&#39;&#39;
    Convert the DiagonalTensor to a tensap.SparseTensor.

    Returns
    -------
    tensap.SparseTensor
        The DiagonalTensor as a tensap.SparseTensor.

    &#39;&#39;&#39;
    ind = np.nonzero(self.data)[0]
    data = self.data[self.data != 0]
    indices = tensap.MultiIndices(np.tile(np.reshape(ind, [-1, 1]),
                                          (1, self.order)))
    return tensap.SparseTensor(data, indices, self.shape)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse_storage"><code class="name flex">
<span>def <span class="ident">sparse_storage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the sparse storage complexity of the DiagonalTensor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The sparse storage complexity of the DiagonalTensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sparse_storage(self):
    &#39;&#39;&#39;
    Return the sparse storage complexity of the DiagonalTensor.

    Returns
    -------
    int
        The sparse storage complexity of the DiagonalTensor.

    &#39;&#39;&#39;
    return np.count_nonzero(self.data)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.storage"><code class="name flex">
<span>def <span class="ident">storage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the storage complexity of the DiagonalTensor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The storage complexity of the DiagonalTensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def storage(self):
    &#39;&#39;&#39;
    Return the storage complexity of the DiagonalTensor.

    Returns
    -------
    int
        The storage complexity of the DiagonalTensor.

    &#39;&#39;&#39;
    return self.data.size</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sub_tensor"><code class="name flex">
<span>def <span class="ident">sub_tensor</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a subtensor of the tensor.</p>
<p>See also tensap.FullTensor.sub_tensor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*indices</code></strong> :&ensp;<code>list</code></dt>
<dd>The indices to extract in each dimension. ':' indicates all the
indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FullTensor</code></dt>
<dd>The subtensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sub_tensor(self, *args):
    &#39;&#39;&#39;
    Extract a subtensor of the tensor.

    See also tensap.FullTensor.sub_tensor.

    Parameters
    ----------
    *indices : list
        The indices to extract in each dimension. &#39;:&#39; indicates all the
        indices.

    Returns
    -------
    FullTensor
        The subtensor.

    &#39;&#39;&#39;

    out = self.full()
    return out.sub_tensor(*args)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_diagonal_matrix_product"><code class="name flex">
<span>def <span class="ident">tensor_diagonal_matrix_product</span></span>(<span>self, matrices)</span>
</code></dt>
<dd>
<div class="desc"><p>Contract a FullTensor with matrices built from their diagonals.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrices</code></strong> :&ensp;<code>numpy.ndarray</code> or <code>list</code> of <code>numpy.ndarray</code></dt>
<dd>The diagonals of the matrices to use in the product.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The tensor after the contractions with the matrices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensor_diagonal_matrix_product(self, matrices):
    &#39;&#39;&#39;
    Contract a FullTensor with matrices built from their diagonals.

    The second dimension of the matrix matrices[k] is contracted with the
    k-th dimension of self.

    Parameters
    ----------
    matrices : numpy.ndarray or list of numpy.ndarray
        The diagonals of the matrices to use in the product.

    Returns
    -------
    DiagonalTensor
        The tensor after the contractions with the matrices.

    &#39;&#39;&#39;
    if isinstance(matrices, list):
        matrices = np.hstack([np.reshape(x, [-1, 1]) for x in matrices])
    return DiagonalTensor(np.prod(matrices, 1) * self.data, self.order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product"><code class="name flex">
<span>def <span class="ident">tensor_matrix_product</span></span>(<span>self, matrices, dims=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contract a tensor with matrices.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<p>See also tensap.FullTensor.tensor_matrix_product.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrices</code></strong> :&ensp;<code>numpy.ndarray</code> or <code>list</code> of <code>numpy.ndarray</code></dt>
<dd>The matrices to use in the product.</dd>
<dt><strong><code>dims</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code>, optional</dt>
<dd>Indices of the contractions. The default is None, indicating all
the dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FullTensor</code></dt>
<dd>The tensor after the contractions with the matrices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensor_matrix_product(self, matrices, dims=None):
    &#39;&#39;&#39;
    Contract a tensor with matrices.

    The second dimension of the matrix matrices[k] is contracted with the
    k-th dimension of self, with the indices k given in dims (if provided).

    See also tensap.FullTensor.tensor_matrix_product.

    Parameters
    ----------
    matrices : numpy.ndarray or list of numpy.ndarray
        The matrices to use in the product.
    dims : list or numpy.ndarray, optional
        Indices of the contractions. The default is None, indicating all
        the dimensions.

    Returns
    -------
    FullTensor
        The tensor after the contractions with the matrices.

    &#39;&#39;&#39;
    out = self.full()
    return out.tensor_matrix_product(matrices, dims)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product_eval_diag"><code class="name flex">
<span>def <span class="ident">tensor_matrix_product_eval_diag</span></span>(<span>self, matrices, dims=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the diagonal of a tensor obtained by contraction with
matrices.</p>
<p>Provides the diagonal of the tensor obtained by contracting the tensor
with matrices H[k] along dimensions dims(k)+1, for k = 0, &hellip;,
dims.size-1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrices</code></strong> :&ensp;<code>list</code></dt>
<dd>The matrices to use in the product.</dd>
<dt><strong><code>dims</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code>, optional</dt>
<dd>Indices of the contractions. The default is None, indicating all
the dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensap.DiagonalTensor</code> or <code>numpy.ndarray</code></dt>
<dd>The diagonal of the contractions of the tensor with the matrices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensor_matrix_product_eval_diag(self, matrices, dims=None):
    &#39;&#39;&#39;
    Evaluate the diagonal of a tensor obtained by contraction with
    matrices.

    Provides the diagonal of the tensor obtained by contracting the tensor
    with matrices H[k] along dimensions dims(k)+1, for k = 0, ...,
    dims.size-1.

    Parameters
    ----------
    matrices : list
        The matrices to use in the product.
    dims : list or numpy.ndarray, optional
        Indices of the contractions. The default is None, indicating all
        the dimensions.

    Returns
    -------
    tensap.DiagonalTensor or numpy.ndarray
        The diagonal of the contractions of the tensor with the matrices.

    &#39;&#39;&#39;
    return self.tensor_matrix_product(matrices, dims).eval_diag(dims)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_vector_product"><code class="name flex">
<span>def <span class="ident">tensor_vector_product</span></span>(<span>self, vectors)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the contraction of the tensor with vectors.</p>
<p>Compute the contraction of self with each vector contained in the list
vectors along all the dimensions. The operation is such that V[k] is
contracted with the k-th dimension of self.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vectors</code></strong> :&ensp;<code>numpy.ndarray</code> or <code>list</code> of <code>numpy.ndarray</code></dt>
<dd>The vectors to use in the product.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The tensor after the contractions with the vectors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensor_vector_product(self, vectors):
    &#39;&#39;&#39;
    Compute the contraction of the tensor with vectors.

    Compute the contraction of self with each vector contained in the list
    vectors along all the dimensions. The operation is such that V[k] is
    contracted with the k-th dimension of self.

    Parameters
    ----------
    vectors : numpy.ndarray or list of numpy.ndarray
        The vectors to use in the product.

    Returns
    -------
    DiagonalTensor
        The tensor after the contractions with the vectors.

    &#39;&#39;&#39;
    if isinstance(vectors, list):
        vectors = np.hstack([np.reshape(x, [-1, 1]) for x in vectors])
    data = self.data * np.prod(vectors, 1)
    order = self.order - vectors.shape[1]
    if order == 0:
        return np.sum(data)
    return DiagonalTensor(data, order)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot"><code class="name flex">
<span>def <span class="ident">tensordot</span></span>(<span>self, y, dims1, dims2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contract two tensors along specified dimensions.</p>
<p>See also tensap.FullTensor.tensordot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tensor2</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>The second tensor of the contraction.</dd>
<dt><strong><code>dims1</code></strong> :&ensp;<code>list</code> or <code>int</code></dt>
<dd>The dimensions of contractions for the first tensor.</dd>
<dt><strong><code>dims2</code></strong> :&ensp;<code>list</code> or <code>int</code>, optional</dt>
<dd>The dimensions of contractions for the second tensor. The default
is None which indicates, if dims1 = 0, to perform the outer
product of the two tensors, similarly to tensorflow.tensordot.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>FullTensor</code></dt>
<dd>The resulting tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensordot(self, y, dims1, dims2=None):
    &#39;&#39;&#39;
    Contract two tensors along specified dimensions.

    See also tensap.FullTensor.tensordot.

    Parameters
    ----------
    tensor2 : Tensor
        The second tensor of the contraction.
    dims1 : list or int
        The dimensions of contractions for the first tensor.
    dims2 : list or int, optional
        The dimensions of contractions for the second tensor. The default
        is None which indicates, if dims1 = 0, to perform the outer
        product of the two tensors, similarly to tensorflow.tensordot.

    Returns
    -------
    out : FullTensor
        The resulting tensor.

    &#39;&#39;&#39;
    x = self.full()
    y = y.full()
    return x.tensordot(y, dims1, dims2)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot_matrix_product_except_dim"><code class="name flex">
<span>def <span class="ident">tensordot_matrix_product_except_dim</span></span>(<span>self, y, matrices, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Particular type of contraction.</p>
<p>Compute a special contraction of two tensors self, y, a list of
matrices matrices and a particular dimension dim. Note that dim must
be a scalar, while matrices must be a list array with self.order
elements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The second tensor of the contraction.</dd>
<dt><strong><code>matrices</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of matrices of the contraction.</dd>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code></dt>
<dd>The excluded dimension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>The result of the contraction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensordot_matrix_product_except_dim(self, y, matrices, dim):
    &#39;&#39;&#39;
    Particular type of contraction.

    Compute a special contraction of two tensors self, y, a list of
    matrices matrices and a particular dimension dim. Note that dim must
    be a scalar, while matrices must be a list array with self.order
    elements.

    Parameters
    ----------
    y : DiagonalTensor
        The second tensor of the contraction.
    matrices : list
        The list of matrices of the contraction.
    dim : int
        The excluded dimension.

    Returns
    -------
    numpy.ndarray
        The result of the contraction.

    &#39;&#39;&#39;
    ind = np.setdiff1d(range(self.order), dim)
    matrices = np.hstack([matrices[x] for x in ind])
    matrices = np.reshape(np.expand_dims(matrices, 1),
                          (self.shape[0], y.shape[0], ind.size),
                          order=&#39;F&#39;)
    matrices = np.prod(matrices, 2)
    return matrices * np.outer(self.data, y.data)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.transpose"><code class="name flex">
<span>def <span class="ident">transpose</span></span>(<span>self, dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Transpose (permute) the dimensions of the tensor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dims</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>The new ordering of the dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tensor</code></strong> :&ensp;<code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></dt>
<dd>The transposed (permuted) tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpose(self, dims):
    &#39;&#39;&#39;
    Transpose (permute) the dimensions of the tensor.

    Parameters
    ----------
    dims : list or numpy.ndarray
        The new ordering of the dimensions.

    Returns
    -------
    tensor : DiagonalTensor
        The transposed (permuted) tensor.

    &#39;&#39;&#39;
    out = deepcopy(self)
    out.shape = out.shape[dims]
    return out</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tree_based_tensor"><code class="name flex">
<span>def <span class="ident">tree_based_tensor</span></span>(<span>self, tree=None, is_active_node=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the tensap.DiagonalTensor into a tensap.TreeBasedTensor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tree</code></strong> :&ensp;<code>tensap.DimensionTree</code>, optional</dt>
<dd>The tree associated with the tree-based tensor representation. The
default is a linear tree.</dd>
<dt><strong><code>is_active_node</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code>, optional</dt>
<dd>List or array of booleans indicating if each node of the tree is
active. The default is True for all nodes except the leaves.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the internal nodes are not all active.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensap.TreeBasedTensor</code></dt>
<dd>A tree-based tensor representation of the diagonal tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree_based_tensor(self, tree=None, is_active_node=None):
    &#39;&#39;&#39;
    Convert the tensap.DiagonalTensor into a tensap.TreeBasedTensor.

    Parameters
    ----------
    tree : tensap.DimensionTree, optional
        The tree associated with the tree-based tensor representation. The
        default is a linear tree.
    is_active_node : list or numpy.ndarray, optional
        List or array of booleans indicating if each node of the tree is
        active. The default is True for all nodes except the leaves.

    Raises
    ------
    ValueError
        If the internal nodes are not all active.

    Returns
    -------
    tensap.TreeBasedTensor
        A tree-based tensor representation of the diagonal tensor.

    &#39;&#39;&#39;
    if tree is None:
        tree = tensap.DimensionTree.linear(self.order)

    if is_active_node is None:
        is_active_node = np.full(tree.nb_nodes, True)
        is_active_node[tree.is_leaf] = False

    tensors = np.empty(tree.nb_nodes, dtype=object)
    tensors[np.logical_not(is_active_node)] = tensap.FullTensor([])
    r = self.shape[0]
    for nod in np.arange(1, tree.nb_nodes+1):
        ch = tree.children(nod)
        if tree.parent(nod) == 0:
            tensors[nod-1] = tensap.FullTensor.diag(self.data, ch.size)
        elif tree.is_leaf[nod-1] and is_active_node[nod-1]:
            tensors[nod-1] = tensap.FullTensor(np.eye(r), 2, [r, r])
        elif is_active_node[nod-1]:
            tensors[nod-1] = tensap.FullTensor.diag(np.ones(r), ch.size+1)
        elif not tree.is_leaf[nod-1] and not is_active_node[nod-1]:
            raise ValueError(&#39;The internal nodes should be active.&#39;)
    return tensap.TreeBasedTensor(tensors, tree)</code></pre>
</details>
</dd>
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.update_attributes"><code class="name flex">
<span>def <span class="ident">update_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the attribute shape of self if data or order have been modified.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_attributes(self):
    &#39;&#39;&#39;
    Update the attribute shape of self if data or order have been modified.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    self.shape = np.full(self.order, self.data.size)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tensap.tensor_algebra.tensors" href="index.html">tensap.tensor_algebra.tensors</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">DiagonalTensor</a></code></h4>
<ul class="">
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.cat" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.cat">cat</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.create" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.create">create</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot">dot</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot_with_rank_one_metric" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot_with_rank_one_metric">dot_with_rank_one_metric</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_at_indices" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_at_indices">eval_at_indices</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_diag" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_diag">eval_diag</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.full" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.full">full</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.itranspose" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.itranspose">itranspose</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.kron" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.kron">kron</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ndim" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ndim">ndim</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.norm" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.norm">norm</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.numpy" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.numpy">numpy</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ones" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ones">ones</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.orth" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.orth">orth</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.rand" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.rand">rand</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.randn" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.randn">randn</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.reshape" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.reshape">reshape</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse">sparse</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse_storage" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse_storage">sparse_storage</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.storage" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.storage">storage</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sub_tensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sub_tensor">sub_tensor</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_diagonal_matrix_product" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_diagonal_matrix_product">tensor_diagonal_matrix_product</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product">tensor_matrix_product</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product_eval_diag" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product_eval_diag">tensor_matrix_product_eval_diag</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_vector_product" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_vector_product">tensor_vector_product</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot">tensordot</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot_matrix_product_except_dim" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot_matrix_product_except_dim">tensordot_matrix_product_except_dim</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.transpose" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.transpose">transpose</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tree_based_tensor" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tree_based_tensor">tree_based_tensor</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.update_attributes" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.update_attributes">update_attributes</a></code></li>
<li><code><a title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.zeros" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>